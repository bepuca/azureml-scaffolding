#!/usr/bin/env bash
#? Isolate artifacts for an package run in a separate directory

set -eo pipefail
cd "$(dirname "$0")/../.."

function usage {
    cat<<EOF
Isolate artifacts for an package run in a separate directory

Usage: $0 PACKAGE RUN_NAME

Options:
    -h, --help            Show this help message and exit

Arguments:
  PACKAGE     Directory of the package relative to "$PKGS_PATH"
  RUN_NAME    Name of the run

The goal is to isolate the absolute minimum to run a package. This aims to
make the run reproducible and portable as well as easy to reason about in
the future.

The run directory will be created in "$RUNS_PATH/PACKAGE/RUN_NAME".
The run directory will contain all files inside PACKAGE and will
add the 'shared' code and the environment files. Thus, the final structure:
  <run_name>
  ├── .amlignore
  ├── azure-ml-job.yaml
  ├── shared/
  ├── tests/
  ├── environment/
  │   ├── Dockerfile
  │   └── requirements.txt
  └── <package>
      ├── __main__.py
      └── ...

The requirements.txt will contain only the dependencies specified for the
package.
EOF
}

bin/chkenv "PKGS_PATH"

while :; do
    case $1 in
        -h|--help) usage; exit ;;
        *) break ;;
    esac
    shift
done

if [ $# -ne 2 ]; then
    echo>&2 "Both PACKAGE and RUN_NAME required."
    usage>&2
    exit 1
fi

pipeline=$1
run_dir=$2
if [[ ! -d "$PKGS_PATH/$package" ]]; then
    echo>&2 "Package directory '$PKGS_PATH/$package' does not exist."
    exit 1
fi

pipeline_path="./pipelines/$pipeline.yaml"

output=$(uv run python - <<EOF
import yaml
with open("$pipeline_path") as f:
    pipeline = yaml.safe_load(f)
for package in pipeline["jobs"]:
    if package != "snapshot":
        print(package.replace("_", "-"))
EOF
)

while read -r package; do
    bin/pkg/iso "$package" "$run_dir/$package"
done <<< "$output"
cp "$pipeline_path" "$run_dir"

# log components to stdout to be available outside
echo "$output"
